import{dataSource1,dataSource2}from"./datasource.js";export class MultiBb{constructor(){}manager=new MultiDbFunctions([dataSource1,dataSource2]);async initialize(){this.manager.dataSources.map((async(t,a)=>{await t.initialize().then((async()=>{})).catch((t=>{}))}))}async synchronize(t){try{await Promise.all(this.manager.dataSources.map((async(a,e)=>{try{return await a.synchronize(t),!0}catch(t){throw t}})))}catch(t){throw new Error("Failed to synchronize one or more database schemas")}}async close(){try{await Promise.all(this.manager.dataSources.map((async(t,a)=>{try{return await t.destroy(),!0}catch(t){throw t}})))}catch(t){throw new Error("Failed to close one or more database connections")}}async executeQuery(t){try{return await Promise.all(this.manager.dataSources.map((async(a,e)=>{try{return{index:e,result:await a.query(t)}}catch(t){throw t}})))}catch(t){throw new Error("Failed to execute query on one or more databases")}}}export class MultiDbFunctions{dataSources;currentIndex=0;connectionCounts;strategy;constructor(t,a="round-robin"){this.dataSources=t,this.strategy=a,this.connectionCounts=new Array(t.length).fill(0)}getDB(){const t=this.dataSources[this.currentIndex];return this.currentIndex=(this.currentIndex+1)%this.dataSources.length,t}selectDb(){switch(this.strategy){case"round-robin":return this.currentIndex=(this.currentIndex+1)%this.dataSources.length,this.currentIndex;case"random":return Math.floor(Math.random()*this.dataSources.length);case"least-connections":const t=Math.min(...this.connectionCounts);return this.connectionCounts.indexOf(t);default:return 0}}async withConnectionTracking(t,a){this.connectionCounts[t]++;try{return await a()}finally{this.connectionCounts[t]--}}validateDbIndex(t){if(t<0||t>=this.dataSources.length)throw new Error("Índice do banco de dados inválido")}async query(t,a){const e=this.getDB().manager;return await e.query(t,a||[])}async save(t,a){try{const e=await this.dataSources[0].manager.save(t,a),r=this.dataSources[0].manager.create(e.constructor,{...e}),n=await Promise.all(this.dataSources.slice(1).map((async t=>{try{return await t.manager.createQueryBuilder().insert().into(e.constructor).values(r).execute()}catch(t){throw t}})));return[e,...n]}catch(t){throw new Error(`Falha ao salvar nos bancos de dados: ${t.message}`)}}createQueryBuilder(t,a,e){const r=this.getDB();if(!r)throw new Error(`Nenhum DataSource encontrado para a entidade: ${t}`);return r.createQueryBuilder(t||"",a||"",e)}find(t,a){return this.getDB().manager.find(t,a)}findOne(t,a){return this.getDB().manager.findOne(t,a)}findOneBy(t,a){return this.getDB().getRepository(t).findOneBy(a)}async update(t,a,e){try{const r=await this.dataSources[0].manager.update(t,a,e);return[r,...await Promise.all(this.dataSources.slice(1).map((async r=>{try{return await r.manager.update(t,a,e)}catch(t){throw t}})))]}catch(t){throw new Error(`Falha ao atualizar nos bancos de dados: ${t.message}`)}}async remove(t,a){try{return[...await Promise.all(this.dataSources.map((async(e,r)=>{try{return await e.manager.delete(t,a)}catch(t){throw t}})))]}catch(t){throw new Error(`Falha ao remover nos bancos de dados: ${t.message}`)}}async delete(t,a){try{return[...await Promise.all(this.dataSources.map((async(e,r)=>{try{return await e.manager.delete(t,a)}catch(t){throw t}})))]}catch(t){throw new Error(`Falha ao remover nos bancos de dados: ${t.message}`)}}setStrategy(t){this.strategy=t}}