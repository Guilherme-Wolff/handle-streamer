var __decorate=this&&this.__decorate||function(e,t,r,i){var s,a=arguments.length,o=a<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,r,i);else for(var n=e.length-1;n>=0;n--)(s=e[n])&&(o=(a<3?s(o):a>3?s(t,r,o):s(t,r))||o);return a>3&&o&&Object.defineProperty(t,r,o),o};import{container,injectable}from"tsyringe";import{Lives}from"../../domain/entities/lives.entity.js";import{LivesRepository}from"../RepositoryImpl/lives.repository.js";import{StreamersService}from"./streamers.service.js";let LiveService=class{LivesRepository=container.resolve(LivesRepository);StreamersService=container.resolve(StreamersService);saveLives=async e=>{try{const t=await this.StreamersService.getStreamerId(e.streamer,e.platform);let r=await new Lives(t,e.streamer,e.platform,String(e.tittle),e.tags?[String(e.tags)]:[""],String(e.country));return await this.LivesRepository.saveLives(r)}catch(e){throw new Error(e.message)}};getAllLives=async()=>{try{return await this.LivesRepository.getAllLives()}catch(e){throw new Error(e.message)}};async getStreamerLives(e,t){const r=await this.LivesRepository.getStreamerLives(e,t);return r||[]}async updateStreamUrls(e,t){await this.LivesRepository.updateStreamUrls(t,e)}async updateThumbnailUrl(e,t){await this.LivesRepository.updateThumbnail(e,t)}async updateChat(e,t){await this.LivesRepository.updateChat(e,t)}async updateThumbnail(e,t,r){const i=await this.LivesRepository.getCurrentLiveThumb(t,r);if(!i)return;let s=i.thumbnail;if(!s){await this.LivesRepository.updateThumbnail(i.id,s)}}async deleteLivesWithoutUrl(e){return this.LivesRepository.deleteLivesWithoutUrl(e)}};LiveService=__decorate([injectable()],LiveService);export{LiveService};