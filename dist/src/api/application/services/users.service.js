var __decorate=this&&this.__decorate||function(e,r,t,s){var o,a=arguments.length,i=a<3?r:null===s?s=Object.getOwnPropertyDescriptor(r,t):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(e,r,t,s);else for(var c=e.length-1;c>=0;c--)(o=e[c])&&(i=(a<3?o(i):a>3?o(r,t,i):o(r,t))||i);return a>3&&i&&Object.defineProperty(r,t,i),i};import"reflect-metadata";import{container,injectable}from"tsyringe";import{UsersRepository}from"../RepositoryImpl/users.repository.js";let UsersService=class{UsersRepository=container.resolve(UsersRepository);getAllUsers=async()=>{try{return await this.UsersRepository.getAllUsers()}catch(e){throw new Error(e.message)}};getUserById=async e=>{try{return await this.UsersRepository.findById(e)}catch(e){throw new Error(e.message)}};addUser=async e=>{try{const r=await this.UsersRepository.isEmailUnique(e.email),t=await this.UsersRepository.isNameUnique(e.name);if(r){if(t)return await this.UsersRepository.addUser(e);throw new Error("Name already exists.")}throw new Error("E-mail already exists.")}catch(e){throw new Error(e.message)}};getPasswordByEmail=async e=>{try{return await this.UsersRepository.getPasswordByEmail(e)}catch(e){throw new Error(e.message)}}};UsersService=__decorate([injectable()],UsersService);export{UsersService};