var __decorate=this&&this.__decorate||function(e,t,r,o){var a,i=arguments.length,s=i<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,o);else for(var c=e.length-1;c>=0;c--)(a=e[c])&&(s=(i<3?a(s):i>3?a(t,r,s):a(t,r))||s);return i>3&&s&&Object.defineProperty(t,r,s),s};import"reflect-metadata";import{container,injectable}from"tsyringe";import{AuthRepository}from"../RepositoryImpl/auth.repository.js";let AuthService=class{AuthRepository=container.resolve(AuthRepository);getAllUsers=async()=>{try{return await this.AuthRepository.getAllUsers()}catch(e){throw new Error(e.message)}};getUserById=async e=>{try{return await this.AuthRepository.findById(e)}catch(e){throw new Error(e.message)}};addUser=async e=>{try{const t=await this.AuthRepository.isEmailUnique(e.email),r=await this.AuthRepository.isNameUnique(e.name);if(t){if(r)return await this.AuthRepository.addUser(e);throw new Error("Name already exists.")}throw new Error("E-mail already exists.")}catch(e){throw new Error(e.message)}};getPasswordByEmail=async e=>{try{return await this.AuthRepository.getPasswordByEmail(e)}catch(e){throw new Error(e.message)}}};AuthService=__decorate([injectable()],AuthService);export{AuthService};