import*as fs from"node:fs";import{promises as fsPromises}from"fs";import{spawn}from"child_process";import{PATH_RESPONSE_UPLOADS,PATH_STREAMS_THUMBNAILS,PATH_STREAMS_OUTPUT}from"../../../../root_path.js";import{LiveService}from"../services/lives.service.js";import axios from"axios";import crypto from"crypto";import{Readable}from"stream";import{BUNKR_ALIAS}from"../config/bunkr.alias.upload.js";export class uploadService{BUCKET_URL="bunkr.ru";AUTH_TOKEN="";PATH_STREAMS_OUTPUT=PATH_STREAMS_OUTPUT;PATH_STREAMS_THUMBNAILS=PATH_STREAMS_THUMBNAILS;PATH_RESPONSE_UPLOADS=PATH_RESPONSE_UPLOADS;TOKEN_BUNKR="7BQHDIcDS5K1RpVD3p7sgwZNOd0It9lkc9IpiVOOAan0UCa6P0fiFxIU9BUWB14J";URL_FOR_GET_SERVER_BUNKRS="https://app.bunkrr.su/api/node";EXTENSION_DEFAULT=".mp4";constructor(){}async getServerBunkr(){const{data:r}=await axios.get(this.URL_FOR_GET_SERVER_BUNKRS,{headers:{token:this.TOKEN_BUNKR}});return r.success?r.url:""}async generateBoundary(){return`---------------------------${(new Date).toISOString().replace(/[-:T.]/g,"").slice(0,14)}${crypto.randomBytes(6).toString("hex")}`}async createFormDataPart(r,e,t,a,s){return Buffer.concat([Buffer.from(`--${s}\r\n`),Buffer.from(`Content-Disposition: form-data; name="${r}"; filename="${e}"\r\n`),Buffer.from(`Content-Type: ${t}\r\n\r\n`),a,Buffer.from("\r\n")])}async checkFileExists(r){try{return await fsPromises.access(r),!0}catch(r){return!1}}async waitForFile(r,e=6e4){const t=Date.now();for(;Date.now()-t<e;)try{return await fsPromises.access(r),!0}catch(r){await new Promise((r=>setTimeout(r,1e3)))}return!1}async uploadStream(r,e,t,a){const s=r+".mp4.json";let n={sucess:!1,url:""};try{const o=await(`${this.PATH_STREAMS_OUTPUT}${r}/${r}${this.EXTENSION_DEFAULT}`);if(!await this.waitForFile(o))return{sucess:!1,url:"",error:"Arquivo nÃ£o encontrado"};const i=await this.getServerBunkr();r=`${r}${this.EXTENSION_DEFAULT}`;const c="----WebKitFormBoundary"+Math.random().toString(36).substring(2);let u;u=new Readable({read(){this.push(Buffer.concat([Buffer.from(`--${c}\r\n`),Buffer.from(`Content-Disposition: form-data; name="files[]"; filename="${r}"\r\n`),Buffer.from("Content-Type: video/mp4\r\n\r\n"),fs.readFileSync(o),Buffer.from("\r\n")])),this.push(Buffer.from(`--${c}--\r\n`)),this.push(null)}});let f=["-X","POST","-H",`Content-Type: multipart/form-data; boundary=${c}`,"-H",`Token: ${this.TOKEN_BUNKR}`,"-H","X-Requested-With: XMLHttpRequest","--data-binary","@-",`${i}`];const p=spawn("curl",f,{stdio:["pipe","pipe","pipe"]});u.pipe(p.stdin),p.on("close",(async s=>{let n={};return 0===s&&(n=await this.pixeldrainReadFileResponseUploadStream(r,e,t,await this.getFoodForUrlFile(i),a)),await n}));const S=fs.createWriteStream(PATH_RESPONSE_UPLOADS+s);return p.stdout.pipe(S),n}catch(r){}}async getFoodForUrlFile(r){const e=r.match(/n(\d+)/)[1];return BUNKR_ALIAS[e]}async createUrlBunkr(r,e){return`https://i-${e}.bunkr.ru/${r}`}async pixeldrainReadFileResponseUploadStream(r,e,t="tiktok",a,s){let n="";return fs.readFile(PATH_RESPONSE_UPLOADS+r+".json","utf8",(async(r,o)=>{if(!r)try{if(n=await JSON.parse(o),n.success&&n.files&&n.files.length>0){const r=n.files[0].name,o=await this.createUrlBunkr(r,a);await this.updateStreamUrl(o,e,t,s)}return await n}catch(r){}})),await n}async updateStreamUrl(r,e,t,a){const s=new LiveService;return await s.updateStreamUrls(r,a)}}