var __decorate=this&&this.__decorate||function(t,e,r,a){var s,i=arguments.length,o=i<3?e:null===a?a=Object.getOwnPropertyDescriptor(e,r):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,r,a);else for(var n=t.length-1;n>=0;n--)(s=t[n])&&(o=(i<3?s(o):i>3?s(e,r,o):s(e,r))||o);return i>3&&o&&Object.defineProperty(e,r,o),o},__metadata=this&&this.__metadata||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)};import"reflect-metadata";import{container,injectable}from"tsyringe";import{Streamers}from"../../domain/entities/streamers.entity.js";import{StreamersRepository}from"../RepositoryImpl/streamers.repository.js";import{Pixeldrain}from"./pixeldrain.service.js";import{FileUtilities}from"../../infrastructure/utils/utils_files.js";let StreamersService=class{constructor(){}StreamersRepository=container.resolve(StreamersRepository);FileUtilities=new FileUtilities;async getCountry(t,e){return await this.StreamersRepository.getCountry(t,e)}async streamerExistInTiktok(t,e="tiktok"){let r={exist:!1,url:""};try{if(await this.StreamersRepository.isStreamerExist_for_Update(t,e))return await r;{let e=await this.FileUtilities.streamerExistInTiktok(t);return r.exist=!0,r.url=e.url,await r}}catch(t){throw new Error(t.message)}}async addStreamer(t,e,r,a){try{if(!await this.StreamersRepository.isStreamerExist_for_update(t,e)){await this.StreamersRepository.addStreamer(t,e,r,a)}}catch(t){throw new Error(t.message)}}async getAllStreamersNameEAvatar(){try{let t=await this.StreamersRepository.getAllStreamersNameEAvatar();if(t)return t}catch(t){throw new Error(t.message)}}async getAllStreamersWithoutCountry(){try{let t=await this.StreamersRepository.getAllStreamers();if(t)return t}catch(t){throw new Error(t.message)}}async getStreamersWithoutSpecificCountries(){try{let t=await this.StreamersRepository.getStreamersWithoutSpecificCountries();if(t)return t}catch(t){throw new Error(t.message)}}async getAvatarInTiktok(t,e="tiktok"){let r={exist:!1,url:""};try{let e=await this.FileUtilities.streamerExistInTiktok(t);return r.exist=!0,r.url=e.url,await r}catch(t){throw new Error(t.message)}}async updateAvatarUrl(t,e,r){try{return await this.StreamersRepository.updateAvatarUrl(t,e,r)}catch(t){throw new Error(t.message)}}async updateCountry(t,e,r){try{return await this.StreamersRepository.updateCountry(t,e,r)}catch(t){throw new Error(t.message)}}async getStreamerId(t,e){try{const r=await this.StreamersRepository.getStreamerId(t,e);return r||""}catch(t){throw new Error(t.message)}}async getUrl(t,e){try{new Streamers(t,e);await this.StreamersRepository.getUrl(t,e)}catch(t){throw new Error(t.message)}}async getStreamersForSaving(){try{return await this.StreamersRepository.getStreamersForSaving()}catch(t){throw new Error(t.message)}}async getStreamersForBan(){try{return await this.StreamersRepository.getStreamersForBan()}catch(t){throw new Error(t.message)}}async returnStreamersToDatabase(t){try{return await this.StreamersRepository.returnStreamersToDatabase(t)}catch(t){throw new Error(t.message)}}async addBan(t,e){try{return await this.StreamersRepository.addBan(t,e)}catch(t){throw new Error(t.message)}}async addAlbumID(t,e,r){try{const a=await this.StreamersRepository.getAlbumStreamer(t,r);if(a.length){const r=new Pixeldrain;return await r.addFileInAlbum(e,a,t)}{const a={title:t,anonymous:!1,files:[{id:e,description:""}]},s=new Pixeldrain,i=await s.createAlbum(a);return await this.StreamersRepository.addAlbumID(t,i,r)}}catch(t){throw new Error(t.message)}}};StreamersService=__decorate([injectable(),__metadata("design:paramtypes",[])],StreamersService);export{StreamersService};